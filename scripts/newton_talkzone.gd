extends Area2D

@export var player_group_name: String = "player"
@export var dialogue_ui_path: NodePath = ^"/root/Game/Hud/DialogueSystem"
@export var image_viewer_path: NodePath = ^"/root/Game/Hud/ImageViewer"

# NEW: drag Madhava's AnimatedSprite2D (world sprite) here in the Inspector
@export var npc_anim_path: NodePath

@export_multiline var npc_dialogue_raw: String = """
...

NEWTON:
Hello. I am Isaac Newton.

NEWTON:
My work connects calculus to motion and change.
I was interested in how quantities vary over time: position, velocity, acceleration, and more general changing quantities.

NEWTON:
I describe changing quantities as fluents-values that "flow" as time passes.
The rates at which they change are fluxions.

NEWTON:
For example, if x is a fluent (a quantity changing with time), then its fluxion is the rate of change of x with respect to time.
In modern notation, this is like dx/dt.

NEWTON:
This idea makes it possible to treat geometry as a problem about motion.
A curve can be generated by a moving point.

NEWTON:
Then a tangent line is determined by the instantaneous direction of motion at a moment in time.

NEWTON:
To find tangents, I compared how two related quantities change together.

NEWTON:
If a point moves so that x changes and y changes at the same time, then the slope of the tangent is the ratio of their rates:
slope = (rate of change of y) / (rate of change of x).

NEWTON:
In modern notation, that is dy/dx, which can be written as (dy/dt) / (dx/dt).
So tangents come from comparing fluxions.

NEWTON:
I also worked on the reverse problem: recovering a quantity from its rate of change.
If you know how fast something changes, you can determine how much it has accumulated over time.

NEWTON:
This is why I saw differentiation and integration as inverse operations.
If you differentiate a quantity, you get its fluxion.

NEWTON:
If you "undo" that process, you recover the fluent.

NEWTON:
In my writing, I called this inverse process the method of quadratures.
It corresponds to finding areas, accumulated quantities, and antiderivatives.

NEWTON:
A simple example is this:

NEWTON:
If a quantity grows at a rate proportional to x^n, then the accumulated quantity involves x^(n+1).
This produces the pattern that later becomes the power rule.

NEWTON:
Beyond geometry, these ideas were essential in physics.
For example, if position changes in time, its fluxion is velocity.

NEWTON:
If velocity changes in time, its fluxion is acceleration.
Then forces can be related to acceleration, allowing motion to be predicted by mathematical laws.

NEWTON:
So my contribution to calculus is a complete framework:
rates of change (fluxions),
relationships between rates (slopes and tangents),
and the reverse process of accumulation through quadratures.

NEWTON:
and recovering quantities from rates (quadratures),
with direct applications to motion and physical law.
"""

# Assign PNGs here in the Inspector (per NPC)
@export var image_pages: Array[Texture2D] = []

@onready var dialogue_ui := get_node_or_null(dialogue_ui_path)
@onready var image_viewer := get_node_or_null(image_viewer_path)
@onready var npc_anim := get_node_or_null(npc_anim_path) as AnimatedSprite2D

var _current_player: Node2D = null
var _dialogue_running: bool = false

func _ready() -> void:
	body_entered.connect(_on_body_entered)

func _on_body_entered(body: Node2D) -> void:
	if _dialogue_running:
		return
	if not body.is_in_group(player_group_name):
		return
	if dialogue_ui == null:
		push_error("TalkZone: DialogueSystem not found at: %s" % dialogue_ui_path)
		return

	_dialogue_running = true
	_current_player = body

	# Freeze player immediately
	if body.has_method("set_controls_enabled"):
		body.call("set_controls_enabled", false)

	# Open dialogue pages
	var pages: PackedStringArray = npc_dialogue_raw.split("\n\n", false)

	# UPDATED: pass Madhava's moving sprite info to DialogueSystem
	if npc_anim != null and npc_anim.sprite_frames != null:
		dialogue_ui.call(
			"open_lines",
			pages,
			npc_anim.sprite_frames,
			npc_anim.animation,
			npc_anim.speed_scale,
			npc_anim.flip_h
		)
	else:
		# Fallback: dialogue text only
		dialogue_ui.call("open_lines", pages)

	# Connect once to dialogue end
	if dialogue_ui.has_signal("dialogue_finished"):
		if not dialogue_ui.dialogue_finished.is_connected(_on_dialogue_finished):
			dialogue_ui.dialogue_finished.connect(_on_dialogue_finished)

func _on_dialogue_finished() -> void:
	# If we have images, show them next (do NOT re-enable movement yet)
	if image_pages.size() > 0 and image_viewer != null and image_viewer.has_method("open_images"):
		if image_viewer.has_signal("images_finished"):
			if not image_viewer.images_finished.is_connected(_on_images_finished):
				image_viewer.images_finished.connect(_on_images_finished)

		image_viewer.call("open_images", image_pages)
		return

	# Otherwise, end normally
	_finish_interaction()

func _on_images_finished() -> void:
	_finish_interaction()

func _finish_interaction() -> void:
	_dialogue_running = false

	if _current_player != null and is_instance_valid(_current_player):
		if _current_player.has_method("set_controls_enabled"):
			_current_player.call("set_controls_enabled", true)

	_current_player = null
